# -*- coding: utf-8 -*-
"""Cirq.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hxiATdXtl7OuPc4WIEoa1Yz3a4Vt9qZb
"""

pip install cirq

import cirq
import numpy as np

print(cirq.google.Bristlecone)

import warnings
warnings.filterwarnings('ignore')
# Get a qubit and a circuit
qbit = cirq.LineQubit(0)
circuit = cirq.Circuit()
# Add an X gate: acts like the Pauli Matrix sigma_x
circuit.append(cirq.X(qbit))

# Run a simple simulation that extracts the wavefunction of this state
sim = cirq.Simulator()
result = sim.simulate(circuit)
print("\nBloch Sphere of the qubit in the final state:")
state = cirq.bloch_vector_from_state_vector(result.final_state,0)
print("x: ", np.around(state[0], 4), " y: ", np.around(state[1], 4),
" z: ", np.around(state[2], 4))

# Add a measurement at the end of the circuit:
circuit.append(cirq.measure(qbit, key="Final state"))
# Display the circuit:
print("\nCircuit:")
print(circuit)

# Invoke the Cirq quantum simulator to execute the circuit:
simulator = cirq.Simulator()
# Simulate the circuit several times:
result = simulator.run(circuit, repetitions=10)

# Print the results:
print("\nResults of 10 trials:")
print(result)

import random
# Define three qubits: msg = qubit[0], qalice = qubit[1], qbob = qubit[2]
qubit=[0]*(3)
qubit[0] = cirq.NamedQubit('msg')
qubit[1] = cirq.NamedQubit('qalice')
qubit[2] = cirq.NamedQubit('qbob')
circuit = cirq.Circuit()
# Create a Bell state entangled pair to be shared between Alice and Bob.
circuit.append([cirq.H(qubit[1]), cirq.CNOT(qubit[1], qubit[2])])
# Creates a random state for the Message.
ranX = random.random()
ranY = random.random()
circuit.append([cirq.X(qubit[0])**ranX, cirq.Y(qubit[0])**ranY])

# Unitary operator rotating the two-qubit basis of the Message and Alice's entangled qubit;
# rotates the Bell state basis to the computational basis:
circuit.append([cirq.CNOT(qubit[0], qubit[1]), cirq.H(qubit[0])])
# Combining now with a measurment in the computational basis,
# we effectively have projected this two-qubit state onto one of the four states of
# the Bell state basis:
circuit.append(cirq.measure(qubit[0], qubit[1]))

# Use the two classical bits from the Bell measurement to recover the
# original quantum Message on Bob's entangled qubit.
circuit.append([cirq.CNOT(qubit[1], qubit[2]), cirq.CZ(qubit[0], qubit[2])])
print("Circuit:")
print(circuit)